#!/usr/bin/env python

"""
This file offers services to interact with the custom library to move
sawyer to different states for the grabbing and throwing sequence

SERVICES:
    /start_up: enable the robot and calibrate the grippers
    /go_to_home_pos: send the robot to a preset home position
    /overhand_throw: executes an overhand
"""

from __future__ import division
import numpy as np
import rospy

from the_mighty_sawyer import MoveArm
from the_mighty_sawyer.imagelib import display_png

from std_srvs.srv import Empty, EmptyResponse, SetBool, SetBoolResponse, Trigger, TriggerResponse
from the_mighty_sawyer.srv import GetPose, GetPoseResponse
from geometry_msgs.msg import Pose


class ServClient(object):

    def __init__(self):

        self.sawyer = MoveArm()

        rospy.Service('start_up', Empty, self.start_up_callback)
        rospy.Service('go_to_home_pos', Empty, self.home_pos_callback)
        rospy.Service('overhand_throw', Empty, self.overhand_callback)
        rospy.Service('actuate_gripper', SetBool, self.actuate_gripper_callback)
        rospy.Service('target_board', Empty, self.target_board_callback)
        rospy.Service('make_adjustments', Empty, self.make_adjustments_callback)

        rospy.wait_for_service('locate_board')
        self.get_board_pose = rospy.ServiceProxy('shans_service_board', Empty)

        rospy.wait_for_service('locate_recent_bag')
        self.get_bag_pose = rospy.ServiceProxy('shans_service_bag', Empty)

        rospy.wait_for_service('get_team')
        self.get_bag_pose = rospy.ServiceProxy('get_team', Trigger)

        self.team = None
        self.color = (0,0,0)

    def start_up_callback(self, _ignore):
        """
        Callback for the start up service.
            1) Enables the robot.
            2) Calibrates the gripper

        This should be called first before trying to interact with the robot
        """
        self.sawyer.initializaton()

        return EmptyResponse()

    def home_pos_callback(self, _ignore):
        """
        Callback for the home position service

        Send the robot to the preconfigured home position.
        """
        self.sawyer.go_to_home_pos()

        return EmptyResponse()

    def overhand_callback(self, _ignore):
        """
        Callback for the overhand throw service
            1) positions the arm in a ready position
            2) Executes the throwing motion
        """

        if not self.team or self.team == 'None':
            resp = self.team_call.call(TriggerRequest())
            self.team = resp.message

            if self.team == 'blue':
                self.color = (255,0,0)
            elif self.team == 'red':
                self.color = (0,0,255)

        self.sawyer.do_over_hand_toss()

        return EmptyResponse()

    def make_adjustments_callback(self, _ignore):
        """
        Gets the board pose and the most recent bag pose and decides whether or
        not to make modifications to the throwing settings
        """

        self.board = self.get_board_pose()
        self.bag = self.get_bag_pose()

        target_range = ((self.sawyer.target_pose.pose.position.x)**2 + (self.sawyer.target_pose.pose.position.y)**2)**.5
        current_range = ((self.board.position.x)**2 + (self.board.position.y)**2)**.5

        # If the board pose is farther than 9in, the update
        if abs(current_range - target_range) > 0.2286:
            rospy.loginfo("Board Change Detected -- Updating Target...")
            self.target_board_callback(Empty())

        if self.bag.position.x == 0 and self.bag.position.y == 0:
            pass
        else:
            self.update_throw()

        return EmptyResponse()

    def target_board_callback(self, _ignore):
        """
        Function to target the board. This will update the defualt parameters so
        sawyer will target the location of board relative to its default throwing
        location

        INPUT:
            data (geometry_msgs/Pose) the current pose of the board.

        """

        # Reset parameters to their default values
        self.sawyer.reset_default_settings()

        # Set first targeting angle
        default_board_pose = Pose()

        # Location of throw without modifying any parameters
        default_board_pose.position.x = -0.44
        default_board_pose.position.y = 0.29
        default_board_pose.position.z = 3.14

        # Store the current board pose here
        self.sawyer.target_pose = self.board

        # Used for Testing
        # self.sawyer.target_pose.pose.position.x = 0.8128
        # self.sawyer.target_pose.pose.position.y = 1.524

        # Calculate the headings of each point relative to the base
        default_heading = np.arctan2(default_board_pose.position.y, default_board_pose.position.x)
        target_heading = np.arctan2(self.sawyer.target_pose.pose.position.y, self.sawyer.target_pose.pose.position.x)

        # Calculate the change in heading
        dtheta_target = default_heading - target_heading

        # Caculate the distance to each point relative to the base
        default_range = ((default_board_pose.position.x)**2 + (default_board_pose.position.y)**2)**.5
        target_range = ((self.sawyer.target_pose.pose.position.x)**2 + (self.sawyer.target_pose.pose.position.y)**2)**.5

        # Calulate the percent change in the distance
        drange_target = (default_range - target_range) / (default_range)

        # Set the angle to throw
        self.sawyer.overhand_target_angle += dtheta_target

        # Set the speed to throw
        self.sawyer.overhand_throw_speed = 1 * (1 - drange_target)

        # Print out updated Parameters
        self.print_params()

    def update_throw(self):
        """
        Function to make adjustments based on sawyers most recent throw.

        Check for overshoot and undershoot by evalauating if the distance between
        the bag and the target is greater than 1ft. and the bag is in quadrent
        2 or 4.

        Check for poor aim by evalauating if the distance between the bag and
        the target is greater than 6in. and the bag is in quadrent 1 or 3, then
        change the targeting angle.

        INPUT:
            data (geometry_msgs/Pose) the current pose of the most recent bag
                                        thrown.
        """

        data = self.bag

        # Used for Testing
        # data.pose.position.x = 1.143
        # data.pose.position.y = 1.8288

        # Get Range and heading from target to the bag
        x_diff_throw = data.pose.position.x - self.sawyer.target_pose.pose.position.x
        y_diff_throw = data.pose.position.y - self.sawyer.target_pose.pose.position.y

        distance_from_target = ((x_diff_throw)**2 + (y_diff_throw)**2)**.5
        angle_from_target = np.arctan2(y_diff_throw, x_diff_throw)

        rospy.loginfo("Bag distance from Board Location: %s", distance_from_target)
        rospy.loginfo("Bag heading from Board Location: %s", angle_from_target)

        needs_adjusting = 0

        # Check for overshoot and undershoot
        # If the distance is greater than 1ft. and the bag is in quadrent 2 or 4
        # Then change the velocity respectively.
        if distance_from_target > 0.3:
            if angle_from_target > 0 and angle_from_target < np.pi/2:
                needs_adjusting = 1
                self.sawyer.overhand_throw_speed -= .1

                display_png('sad.png', self.color)

                # Check for a minimum speed setting
                if self.sawyer.overhand_throw_speed < .6:
                    self.sawyer.overhand_throw_speed = .6
                    rospy.loginfo("Overshoot Detected -- At Min Speed")
                else:
                    rospy.loginfo("Overshoot Detected -- Decreasing throwing speed")


            elif angle_from_target < -np.pi/2 and angle_from_target > -np.pi:
                needs_adjusting = 1
                self.sawyer.overhand_throw_speed += .1

                display_png('angry.png', self.color)

                # Check for a maximum speed setting
                if self.sawyer.overhand_throw_speed > 1:
                    self.sawyer.overhand_throw_speed = 1
                    rospy.loginfo("Undershoot Detected -- At Max Speed")
                else:
                    rospy.loginfo("Undershoot Detected -- Increasing throwing speed")

        # Check for poor aim
        # If the distance from the target is greater than 6in. and the bag is in
        # quadrent 1 or 3,
        # Then change the targeting angle
        if distance_from_target > 0.15:
            if (angle_from_target > -np.pi/2 and angle_from_target < 0) or (angle_from_target > np.pi/2 and angle_from_target < np.pi):
                needs_adjusting = 1
                rospy.loginfo("Heading too far off -- Updating Throwing Angle")

                target_heading = np.arctan2(self.sawyer.target_pose.pose.position.y, self.sawyer.target_pose.pose.position.x)
                bag_heading = np.arctan2(data.pose.position.y, data.pose.position.x)

                dtheta_adjust =  bag_heading - target_heading

                self.sawyer.overhand_target_angle += dtheta_adjust

        if needs_adjusting == 0:
            display_png('happy.png', self.color)

        self.print_params()

    def actuate_gripper_callback(self, data):
        """
        Callback for the gripper service

        INPUTS:
            data (SetBool): 1 to open grippers, 0 to close grippers
        """
        self.sawyer.actuate_gripper(data)

        return SetBoolResponse(success=True,message="")

    def print_params(self):
        rospy.loginfo("====================  ADJUSTMENTS ====================")
        rospy.loginfo("Targeting Angle: %s", self.sawyer.overhand_target_angle)
        rospy.loginfo("Throwing Speed: %s", self.sawyer.overhand_throw_speed)
        rospy.loginfo("Release Angle: %s", self.sawyer.overhand_release_angle)
        rospy.loginfo("======================================================")


def main():

    rospy.init_node('sawyer_movement_server')

    ServClient()

    rospy.loginfo("Movement Server Ready!")

    rospy.spin()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
