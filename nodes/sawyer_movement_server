#!/usr/bin/env python

"""
This file offers services to interact with the custom library to move
sawyer to different states for the grabbing and throwing sequence
"""

# TODO: get default parameters from yaml file.

from __future__ import division
import numpy as np
import rospy

from the_mighty_sawyer import MoveArm

from std_srvs.srv import Empty, EmptyResponse, SetBool, SetBoolResponse
from the_mighty_sawyer.srv import GetPose, GetPoseResponse
from geometry_msgs.msg import Pose

class ServClient(object):

    def __init__(self):

        self.sawyer = MoveArm()

        rospy.Service('start_up', Empty, self.start_up_callback)
        rospy.Service('go_to_home_pos', Empty, self.home_pos_callback)
        rospy.Service('overhand_throw', Empty, self.overhand_callback)
        rospy.Service('actuate_gripper', SetBool, self.actuate_gripper_callback)
        rospy.Service('make_adjustments', GetPose, self.make_adjustments_callback)
        rospy.Service('target_board', GetPose, self.target_board_callback)

        self.initial_targeting_angle = None

    def start_up_callback(self, _ignore):
        """
        Callback for the start up service.
            1) Enables the robot.
            2) Calibrates the gripper

        This should be called first before trying to interact with the robot
        """
        self.sawyer.initializaton()

        return EmptyResponse()

    def home_pos_callback(self, _ignore):
        """
        Callback for the home position service

        Send the robot to the preconfigured home position.
        """
        self.sawyer.go_to_home_pos()

        return EmptyResponse()

    def overhand_callback(self, _ignore):
        """
        Callback for the overhand throw service
            1) positions the arm in a ready position
            2) Executes the throwing motion
        """
        self.sawyer.do_over_hand_toss()

        return EmptyResponse()

    def target_board_callback(self, data):
        # Set first targeting angle
        default_board_pose = Pose()

        # Location of throw without modifying any parameters
        default_board_pose.position.x = 0.4064
        default_board_pose.position.y = 2.1336

        # Store the current board pose here
        self.sawyer.target_pose = data
        self.sawyer.target_pose.pose.position.x = 0.8128
        self.sawyer.target_pose.pose.position.y = 1.524

        # Calculate the headings of each point relative to the base
        default_heading = np.arctan2(default_board_pose.position.y, default_board_pose.position.x)
        target_heading = np.arctan2(self.sawyer.target_pose.pose.position.y, self.sawyer.target_pose.pose.position.x)

        # Calculate the change in heading
        dtheta_target = default_heading - target_heading

        # Caculate the distance to each point relative to the base
        default_range = ((default_board_pose.position.x)**2 + (default_board_pose.position.y)**2)**.5
        target_range = ((self.sawyer.target_pose.pose.position.x)**2 + (self.sawyer.target_pose.pose.position.y)**2)**.5

        # Calulate the percent change in the distance
        drange_target = (default_range - target_range) / (default_range)

        # Set the angle to throw
        self.sawyer.overhand_target_angle += dtheta_target
        self.initial_targeting_angle = self.sawyer.overhand_target_angle

        # Set the distance to throw
        self.sawyer.overhand_throw_speed = 1 * (1 - drange_target)

        # Print out updated Parameters
        self.print_params()

        return GetPoseResponse()

    def print_params(self):
        rospy.loginfo("====================  ADJUSTMENTS ====================")
        rospy.loginfo("Targeting Angle: %s", self.sawyer.overhand_target_angle)
        rospy.loginfo("Throwing Speed: %s", self.sawyer.overhand_throw_speed)
        rospy.loginfo("Release Angle: %s", self.sawyer.overhand_release_angle)
        rospy.loginfo("======================================================")

    def make_adjustments_callback(self, data):
        """
        Callback for the make adjustments service
        """
        bag_pose = data

        bag_pose.pose.position.x = 1.143
        bag_pose.pose.position.y = 1.8288

        # Get Range and heading from target to the bag
        x_diff_throw = bag_pose.pose.position.x - self.sawyer.target_pose.pose.position.x
        y_diff_throw = bag_pose.pose.position.y - self.sawyer.target_pose.pose.position.y

        distance_from_target = ((x_diff_throw)**2 + (y_diff_throw)**2)**.5
        angle_from_target = np.arctan2(y_diff_throw, x_diff_throw)

        rospy.loginfo(distance_from_target)
        rospy.loginfo(angle_from_target)

        # Check for overshoot and undershoot
        # If the distance is greater than 2ft. and the bag is in quadrent 2 or 4
        # Then change the velocity respectively.
        if distance_from_target > 0.3:
            if angle_from_target > 0 and angle_from_target < np.pi/2:
                self.sawyer.overhand_throw_speed -= .1

                if self.sawyer.overhand_throw_speed < .6:
                    self.sawyer.overhand_throw_speed = .6
                    rospy.loginfo("Overshoot Detected -- At Min Speed")
                else:
                    rospy.loginfo("Overshoot Detected -- Decreasing throwing speed")


            elif angle_from_target < -np.pi/2 and angle_from_target > -np.pi:
                self.sawyer.overhand_throw_speed += .1

                if self.sawyer.overhand_throw_speed > 1:
                    self.sawyer.overhand_throw_speed = 1
                    rospy.loginfo("Undershoot Detected -- At Max Speed")
                else:
                    rospy.loginfo("Undershoot Detected -- Increasing throwing speed")

        # Check for poor aim
        # If the distance from the target is greater than 1ft. and the bag is in
        # quadrent 1 or 3,
        # Then change the targeting angle
        if distance_from_target > 0.15:
            if (angle_from_target > -np.pi/2 and angle_from_target < 0) or (angle_from_target > np.pi/2 and angle_from_target < np.pi):
                rospy.loginfo("Heading too far off -- Updating Throwing Angle")

                target_heading = np.arctan2(self.sawyer.target_pose.pose.position.y, self.sawyer.target_pose.pose.position.x)
                bag_heading = np.arctan2(bag_pose.pose.position.y, bag_pose.pose.position.x)

                dtheta_adjust =  bag_heading - target_heading

                self.sawyer.overhand_target_angle += dtheta_adjust

        self.print_params()

        return GetPoseResponse()

    def actuate_gripper_callback(self, data):
        """
        Callback for the gripper service

        INPUTS:
            data (SetBool): 1 to open grippers, 0 to close grippers
        """
        self.sawyer.actuate_gripper(data)

        return SetBoolResponse(success=True,message="")

def main():

    rospy.init_node('sawyer_movement_server')

    ServClient()

    rospy.loginfo("Movement Server Ready!")

    rospy.spin()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
